-- =============================================================
-- eng_hybrid_ipa.lua
-- English G2P Phonemizer for VocalAlignerGUI
-- Pipeline: CMUdict -> Affix Stripping -> NRL Rules -> IPA
--
-- Data required:
--   lua/data/cmudict.txt  (CMU Pronouncing Dictionary 0.7b)
--
-- NRL rules are embedded below (generated by nrl_to_lua.py).
-- =============================================================

local profile = {}

profile.id          = "eng_hybrid_ipa"
profile.display_name = "English Hybrid (CMU + NRL → IPA)"
profile.encoding    = "IPA"

-- 39 Standard CMU ARPAbet symbols (from CMU_phonemes.txt analysis)
-- These are the ONLY symbols that will ever appear in output.
profile.supported_symbols = {
    "ɑ",  "æ",  "ʌ",   "ə",  "ɔ",  "aʊ", "aɪ",
    "b",  "tʃ", "d",  "ð",  "ɛ",  "ɝ",
    "eɪ", "f",  "ɡ",  "h",  "ɪ",  "i",
    "dʒ", "k",  "l",  "m",  "n",  "ŋ",
    "oʊ", "ɔɪ", "p",  "ɹ",  "s",  "ʃ",
    "t",  "θ",  "ʊ",  "u",  "v",  "w",
    "j",  "z",  "ʒ",  "sil"
}

-- =============================================================
-- SECTION 1: ARPAbet -> IPA conversion table
-- Strict 1:1 mapping. All 39 CMU symbols covered.
-- NRL extras (AX, IX, NX, DX, WH) normalized to CMU first.
-- =============================================================
local ARPA_TO_IPA = {
    -- Vowels
    ["AA"] = "ɑ",   ["AE"] = "æ",   ["AH"] = "ʌ",   ["AO"] = "ɔ",
    ["AX"] = "ə",
    ["AW"] = "aʊ",  ["AY"] = "aɪ",  ["EH"] = "ɛ",   ["ER"] = "ɝ",
    ["EY"] = "eɪ",  ["IH"] = "ɪ",   ["IY"] = "i",   ["OW"] = "oʊ",
    ["OY"] = "ɔɪ",  ["UH"] = "ʊ",   ["UW"] = "u",
    -- Consonants
    ["B"]  = "b",   ["CH"] = "tʃ",  ["D"]  = "d",   ["DH"] = "ð",
    ["F"]  = "f",   ["G"]  = "ɡ",   ["HH"] = "h",   ["JH"] = "dʒ",
    ["K"]  = "k",   ["L"]  = "l",   ["M"]  = "m",   ["N"]  = "n",
    ["NG"] = "ŋ",   ["P"]  = "p",   ["R"]  = "ɹ",   ["S"]  = "s",
    ["SH"] = "ʃ",   ["T"]  = "t",   ["TH"] = "θ",   ["V"]  = "v",
    ["W"]  = "w",   ["Y"]  = "j",   ["Z"]  = "z",   ["ZH"] = "ʒ",
    -- Silence / Unknown
    ["SIL"] = "sil",
}

-- =============================================================
-- SECTION 2: NRL Extra -> CMU ARPAbet normalization
-- Applied AFTER NRL rule engine produces output,
-- BEFORE ARPAbet -> IPA conversion.
-- =============================================================
local NRL_NORMALIZE = {
    ["AX"] = "AX",   -- Schwa          -> preserved as ə
    ["IX"] = "IH",   -- Reduced I      -> Near-close front
    ["NX"] = "NG",   -- Nasal flap     -> Velar nasal
    ["DX"] = "T",    -- Flap T         -> Voiceless alveolar
    ["WH"] = "W",    -- Voiceless W    -> Voiced labial-velar
}

-- =============================================================
-- SECTION 3: Affix Tables (Middle Layer)
-- Suffixes: ordered longest-first to avoid partial matches.
-- Prefixes: common derivational prefixes.
-- Each entry: { strip, restore_fn, phonemes }
--   strip      = suffix string to remove from word end
--   restore_fn = function(root) -> candidate root spellings to try
--   phonemes   = ARPAbet for this affix
-- =============================================================
local SUFFIXES = {
    -- Longer suffixes first (order matters!)
    { strip="INGLY",  phonemes="IH NG L IY", restore=function(r) return {r} end },
    { strip="INGLY",  phonemes="IH NG L IY", restore=function(r) return {r.."E"} end },
    { strip="NESSES", phonemes="N AH S IH Z", restore=function(r) return {r} end },
    { strip="NESS",   phonemes="N AH S",      restore=function(r) return {r} end },
    { strip="MENTS",  phonemes="M AH N T S",  restore=function(r) return {r} end },
    { strip="MENT",   phonemes="M AH N T",    restore=function(r) return {r} end },
    { strip="INGS",   phonemes="IH NG Z",     restore=function(r) return {r, r.."E"} end },
    { strip="ING",    phonemes="IH NG",       restore=function(r)
        -- e.g. RUNNING -> RUN (doubled consonant), MAKING -> MAKE (e-drop)
        local last = r:sub(-1)
        local candidates = { r, r.."E" }
        -- doubled consonant: RUNNING -> r="RUNN" -> try "RUN"
        if #r >= 2 and r:sub(-1) == r:sub(-2,-2) then
            table.insert(candidates, r:sub(1,-2))
        end
        return candidates
    end },
    { strip="TION",   phonemes="SH AH N",    restore=function(r) return {r, r.."T", r.."TE"} end },
    { strip="SION",   phonemes="ZH AH N",    restore=function(r) return {r, r.."D", r.."DE"} end },
    { strip="EDLY",   phonemes="IH D L IY",  restore=function(r) return {r, r.."E"} end },
    { strip="EDLY",   phonemes="AH D L IY",  restore=function(r) return {r} end },
    { strip="NESS",   phonemes="N AH S",     restore=function(r) return {r} end },
    { strip="LESS",   phonemes="L AH S",     restore=function(r) return {r} end },
    { strip="NESS",   phonemes="N IH S",     restore=function(r) return {r} end },
    { strip="ABLE",   phonemes="AH B AH L",  restore=function(r) return {r, r.."E"} end },
    { strip="IBLE",   phonemes="AH B AH L",  restore=function(r) return {r} end },
    { strip="ICAL",   phonemes="IH K AH L",  restore=function(r) return {r, r.."Y"} end },
    { strip="NESS",   phonemes="N AH S",     restore=function(r) return {r} end },
    { strip="IZED",   phonemes="AY Z D",     restore=function(r) return {r, r.."IZE"} end },
    { strip="IZES",   phonemes="AY Z IH Z",  restore=function(r) return {r, r.."IZE"} end },
    { strip="IZE",    phonemes="AY Z",       restore=function(r) return {r} end },
    { strip="ISED",   phonemes="AY Z D",     restore=function(r) return {r} end },
    { strip="ISES",   phonemes="AY Z IH Z",  restore=function(r) return {r} end },
    { strip="ISE",    phonemes="AY Z",       restore=function(r) return {r} end },
    { strip="FUL",    phonemes="F UH L",     restore=function(r) return {r} end },
    { strip="LY",     phonemes="L IY",       restore=function(r) return {r, r.."LE", r.."AL"} end },
    { strip="LY",     phonemes="L IY",       restore=function(r) return {r} end },
    { strip="ER",     phonemes="ER",         restore=function(r)
        local candidates = { r, r.."E" }
        if #r >= 2 and r:sub(-1) == r:sub(-2,-2) then
            table.insert(candidates, r:sub(1,-2))
        end
        return candidates
    end },
    { strip="EST",    phonemes="AH S T",     restore=function(r)
        local candidates = { r, r.."E" }
        if #r >= 2 and r:sub(-1) == r:sub(-2,-2) then
            table.insert(candidates, r:sub(1,-2))
        end
        return candidates
    end },
    { strip="ED",     phonemes="D",          restore=function(r)
        local candidates = { r, r.."E" }
        if #r >= 2 and r:sub(-1) == r:sub(-2,-2) then
            table.insert(candidates, r:sub(1,-2))
        end
        return candidates
    end },
    { strip="ES",     phonemes="IH Z",       restore=function(r) return {r, r.."E"} end },
    { strip="S",      phonemes="S",          restore=function(r) return {r} end },
    { strip="S",      phonemes="Z",          restore=function(r) return {r} end },
    { strip="D",      phonemes="D",          restore=function(r) return {r, r.."E"} end },
}

local PREFIXES = {
    -- Longer prefixes first
    { match="ANTI",  phonemes="AE N T IY" },
    { match="INTER", phonemes="IH N T ER" },
    { match="OVER",  phonemes="OW V ER"   },
    { match="UNDER", phonemes="AH N D ER" },
    { match="SUPER", phonemes="S UW P ER" },
    { match="OUT",   phonemes="AW T"      },
    { match="PRE",   phonemes="P R IY"    },
    { match="MIS",   phonemes="M IH S"    },
    { match="DIS",   phonemes="D IH S"    },
    { match="NON",   phonemes="N AA N"    },
    { match="MID",   phonemes="M IH D"    },
    { match="RE",    phonemes="R IY"      },
    { match="UN",    phonemes="AH N"      },
    { match="IN",    phonemes="IH N"      },
    { match="IM",    phonemes="IH M"      },
    { match="DE",    phonemes="D IY"      },
    { match="EN",    phonemes="EH N"      },
}

-- =============================================================
-- SECTION 4: NRL Rule Engine
-- Rules are defined below in SECTION 5 (placeholder).
-- Engine iterates word left-to-right, greedy-longest match.
-- =============================================================

-- Helper: Check if Lua pattern matches at end of string (simulates $)
local function match_left(context, pattern)
    if not pattern then return true end
    -- Anchor to end of string
    return context:match(pattern .. "$") ~= nil
end

-- Helper: Check if Lua pattern matches at start of string (simulates ^)
local function match_right(context, pattern)
    if not pattern then return true end
    -- Anchor to start of string
    return context:match("^" .. pattern) ~= nil
end

-- Helper: Normalize NRL phoneme string to CMU ARPAbet
local function normalize_nrl(phoneme_str)
    if not phoneme_str or phoneme_str == "" then return "" end
    local tokens = vocal.text.split(phoneme_str, " ")
    local normalized = {}
    for _, tok in ipairs(tokens) do
        local t = vocal.text.trim(tok)
        if t ~= "" then
            table.insert(normalized, NRL_NORMALIZE[t] or t)
        end
    end
    return table.concat(normalized, " ")
end

-- Core NRL word processor
local function nrl_g2p(word, rules)
    -- Pad with sentinel spaces (mirrors the Perl script logic)
    local padded = " " .. word:upper() .. " "
    local len    = #padded
    local idx    = 2  -- Start after leading space
    local output = {}

    while idx <= len - 1 do
        local char = padded:sub(idx, idx)

        -- Get rule candidates for this character
        -- Try uppercase char key first, then NUMBER group for digits
        local candidates = rules[char] or rules["NUMBER"] or {}
        local matched    = false

        for _, rule in ipairs(candidates) do
            local target  = rule[1]
            local tgt_len = #target

            -- 1. Bounds check
            if idx + tgt_len - 1 <= len - 1 then

                -- 2. Target match
                if padded:sub(idx, idx + tgt_len - 1) == target then

                    -- 3. Left context check
                    local left_ctx = padded:sub(1, idx - 1)
                    local left_ok  = match_left(left_ctx, rule.left)

                    if left_ok then
                        -- 4. Right context check
                        local right_ctx = padded:sub(idx + tgt_len)
                        local right_ok  = match_right(right_ctx, rule.right)

                        if right_ok then
                            -- 5. Match found
                            local phonemes = normalize_nrl(rule[2])
                            if phonemes ~= "" then
                                table.insert(output, phonemes)
                            end
                            idx     = idx + tgt_len
                            matched = true
                            break
                        end
                    end
                end
            end
        end

        if not matched then
            -- No rule matched this character. Skip it silently.
            -- This should be rare (only truly unknown symbols).
            vocal.log("NRL: no rule for char '" .. char .. "' in word '" .. word .. "'")
            idx = idx + 1
        end
    end

    return table.concat(output, " ")
end

-- =============================================================
-- nrl_rules.lua  (AUTO-GENERATED by nrl_to_lua.py)
-- DO NOT EDIT MANUALLY
-- Source: eng_to_ipa.json  (NRL 1976 rules)
-- Phonemes normalized to standard CMU ARPAbet.
-- =============================================================
local NRL_RULES = {

    ["0"] = {
        { "0", "Z IH R OW" },
    },

    ["1"] = {
        { "1", "W AH N" },
    },

    ["2"] = {
        { "2", "T UW" },
    },

    ["3"] = {
        { "3", "TH R IY" },
    },

    ["4"] = {
        { "4", "F OW R" },
    },

    ["5"] = {
        { "5", "F AY V" },
    },

    ["6"] = {
        { "6", "S IH K S" },
    },

    ["7"] = {
        { "7", "S EH V AH N" },
    },

    ["8"] = {
        { "8", "EY T" },
    },

    ["9"] = {
        { "9", "N AY N" },
    },

    ["A"] = {
        { "A", "AH", right="^ " },
        { "ARE", "AA R", left=" $", right="^ " },
        { "AR", "AH R", left=" $", right="^O" },
        { "AR", "EH R", right="^[AEIOUY]+" },
        { "AS", "EY S", left=" [BCDFGHJKLMNPQRSTVWXZ]$", right="^[AEIOUY]+" },
        { "A", "AH", right="^WA" },
        { "AW", "AO" },
        { "ANY", "EH N IY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$" },
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY][AEIOUY]+" },
        { "ALLY", "AH L IY", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$" },
        { "AL", "AH L", left=" $", right="^[AEIOUY]+" },
        { "AGAIN", "AH G EH N" },
        { "AG", "IH JH", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^E" },
        { "A", "AE", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY][BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+" },
        { "A", "EY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY] " },
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]ER" },  -- (expanded)
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]E" },  -- (expanded)
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]ES" },  -- (expanded)
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]ED" },  -- (expanded)
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]ING" },  -- (expanded)
        { "A", "EY", right="^[BCDFGHJKLMNPQRSTVWXZ]ELY" },  -- (expanded)
        { "ARR", "AH R", left=" $" },
        { "ARR", "AE R" },
        { "AR", "AA R", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "AR", "ER", right="^ " },
        { "AR", "AA R" },
        { "AIR", "EH R" },
        { "AI", "EY" },
        { "AY", "EY" },
        { "AU", "AO" },
        { "AL", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "ALS", "AH L Z", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "ALK", "AO K" },
        { "AL", "AO L", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "ABLE", "EY B AH L", left=" [BCDFGHJKLMNPQRSTVWXZ]*$" },
        { "ABLE", "AH B AH L" },
        { "ANG", "EY N JH", right="^[EIY]" },
        { "A", "AE" },
    },

    ["B"] = {
        { "BE", "B IH", left=" $", right="^[BCDFGHJKLMNPQRSTVWXZ][AEIOUY]+" },
        { "BEING", "B IY IH NG" },
        { "BOTH", "B OW TH", left=" $", right="^ " },
        { "BUS", "B IH Z", left=" $", right="^[AEIOUY]+" },
        { "BUIL", "B IH L" },
        { "B", "B" },
    },

    ["C"] = {
        { "CH", "K", left=" $", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "CH", "K", left="[BCDFGHJKLMNPQRSTVWXZ]E$" },
        { "CH", "CH" },
        { "CI", "S AY", left=" S$", right="^[AEIOUY]+" },
        { "CI", "SH", right="^A" },
        { "CI", "SH", right="^O" },
        { "CI", "SH", right="^EN" },
        { "C", "S", right="^[EIY]" },
        { "CK", "K" },
        { "COM", "K AH M", right="^ER" },  -- (expanded)
        { "COM", "K AH M", right="^E" },  -- (expanded)
        { "COM", "K AH M", right="^ES" },  -- (expanded)
        { "COM", "K AH M", right="^ED" },  -- (expanded)
        { "COM", "K AH M", right="^ING" },  -- (expanded)
        { "COM", "K AH M", right="^ELY" },  -- (expanded)
        { "C", "K" },
    },

    ["D"] = {
        { "DED", "D IH D", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "D", "D", left="[BDVGJLMNRWZ]E$", right="^ " },
        { "D", "T", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*E$", right="^ " },
        { "DE", "D IH", left=" $", right="^[BCDFGHJKLMNPQRSTVWXZ][AEIOUY]+" },
        { "DO", "D UW", left=" $", right="^ " },
        { "DOES", "D AH Z", left=" $" },
        { "DOING", "D UW IH NG", left=" $" },
        { "DOW", "D AW", left=" $" },
        { "DU", "JH UW", right="^A" },
        { "D", "D" },
    },

    ["E"] = {
        { "E", "", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "E", "", left="' [BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "E", "IY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "ED", "D", left="[AEIOUY]+$", right="^ " },
        { "E", "", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^D " },
        { "EV", "EH V", right="^ER" },
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]ER" },  -- (expanded)
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]E" },  -- (expanded)
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]ES" },  -- (expanded)
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]ED" },  -- (expanded)
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]ING" },  -- (expanded)
        { "E", "IY", right="^[BCDFGHJKLMNPQRSTVWXZ]ELY" },  -- (expanded)
        { "ERI", "IY R IY", right="^[AEIOUY]+" },
        { "ERI", "EH R IH" },
        { "ER", "ER", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^[AEIOUY]+" },
        { "ER", "EH R", right="^[AEIOUY]+" },
        { "ER", "ER" },
        { "EVEN", "IY V EH N", left=" $" },
        { "E", "", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^W" },
        { "EW", "UW", left="[TSRDLZNJ]$" },  -- (expanded)
        { "EW", "UW", left="TH$" },  -- (expanded)
        { "EW", "UW", left="CH$" },  -- (expanded)
        { "EW", "UW", left="SH$" },  -- (expanded)
        { "EW", "Y UW" },
        { "E", "IY", right="^O" },
        { "ES", "IH Z", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*[SCGZXJ]$", right="^ " },
        { "E", "", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^S " },
        { "ELY", "L IY", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "EMENT", "M EH N T", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$" },
        { "EFUL", "F UH L" },
        { "EE", "IY" },
        { "EARN", "ER N" },
        { "EAR", "ER", left=" $", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "EAD", "EH D" },
        { "EA", "IY AH", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "EA", "EH", right="^SU" },
        { "EA", "IY" },
        { "EIGH", "EY" },
        { "EI", "IY" },
        { "EYE", "AY", left=" $" },
        { "EY", "IY" },
        { "EU", "Y UW" },
        { "E", "EH" },
    },

    ["F"] = {
        { "FUL", "F UH L" },
        { "F", "F" },
    },

    ["G"] = {
        { "GIV", "G IH V" },
        { "G", "G", left=" $", right="^I[BCDFGHJKLMNPQRSTVWXZ]" },
        { "GE", "G EH", right="^T" },
        { "GGES", "G JH EH S", left="SU$" },
        { "GG", "G" },
        { "G", "G", left=" B[AEIOUY]+$" },
        { "G", "JH", right="^[EIY]" },
        { "GREAT", "G R EY T" },
        { "GH", "", left="[AEIOUY]+$" },
        { "G", "G" },
    },

    ["H"] = {
        { "HAV", "HH AE V", left=" $" },
        { "HERE", "HH IY R", left=" $" },
        { "HOUR", "AW ER", left=" $" },
        { "HOW", "HH AW" },
        { "H", "HH", right="^[AEIOUY]+" },
        { "H", "" },
    },

    ["I"] = {
        { "IN", "IH N", left=" $" },
        { "I", "AY", left=" $", right="^ " },
        { "IN", "AY N", right="^D" },
        { "IER", "IY ER" },
        { "IED", "IY D", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*R$", right="^ " },
        { "IED", "AY D", right="^ " },
        { "IEN", "IY EH N" },
        { "IE", "AY EH", right="^T" },
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ER" },  -- (expanded)
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^E" },  -- (expanded)
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ES" },  -- (expanded)
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ED" },  -- (expanded)
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ING" },  -- (expanded)
        { "I", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ELY" },  -- (expanded)
        { "I", "IY", right="^ER" },  -- (expanded)
        { "I", "IY", right="^E" },  -- (expanded)
        { "I", "IY", right="^ES" },  -- (expanded)
        { "I", "IY", right="^ED" },  -- (expanded)
        { "I", "IY", right="^ING" },  -- (expanded)
        { "I", "IY", right="^ELY" },  -- (expanded)
        { "IE", "IY" },
        { "I", "IH", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY][BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+" },
        { "IR", "AY R", right="^[AEIOUY]+" },
        { "IZ", "AY Z", right="^ER" },  -- (expanded)
        { "IZ", "AY Z", right="^E" },  -- (expanded)
        { "IZ", "AY Z", right="^ES" },  -- (expanded)
        { "IZ", "AY Z", right="^ED" },  -- (expanded)
        { "IZ", "AY Z", right="^ING" },  -- (expanded)
        { "IZ", "AY Z", right="^ELY" },  -- (expanded)
        { "IS", "AY Z", right="^ER" },  -- (expanded)
        { "IS", "AY Z", right="^E" },  -- (expanded)
        { "IS", "AY Z", right="^ES" },  -- (expanded)
        { "IS", "AY Z", right="^ED" },  -- (expanded)
        { "IS", "AY Z", right="^ING" },  -- (expanded)
        { "IS", "AY Z", right="^ELY" },  -- (expanded)
        { "I", "AY", right="^DER" },  -- (expanded)
        { "I", "AY", right="^DE" },  -- (expanded)
        { "I", "AY", right="^DES" },  -- (expanded)
        { "I", "AY", right="^DED" },  -- (expanded)
        { "I", "AY", right="^DING" },  -- (expanded)
        { "I", "AY", right="^DELY" },  -- (expanded)
        { "I", "IH", left="[EIY][BCDFGHJKLMNPQRSTVWXZ]$", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY]" },
        { "I", "AY", right="^TER" },  -- (expanded)
        { "I", "AY", right="^TE" },  -- (expanded)
        { "I", "AY", right="^TES" },  -- (expanded)
        { "I", "AY", right="^TED" },  -- (expanded)
        { "I", "AY", right="^TING" },  -- (expanded)
        { "I", "AY", right="^TELY" },  -- (expanded)
        { "I", "IH", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY]" },
        { "I", "AY", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY]" },
        { "IR", "ER" },
        { "IGH", "AY" },
        { "ILD", "AY L D" },
        { "IGN", "AY N", right="^ " },
        { "IGN", "AY N", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "IGN", "AY N", right="^ER" },  -- (expanded)
        { "IGN", "AY N", right="^E" },  -- (expanded)
        { "IGN", "AY N", right="^ES" },  -- (expanded)
        { "IGN", "AY N", right="^ED" },  -- (expanded)
        { "IGN", "AY N", right="^ING" },  -- (expanded)
        { "IGN", "AY N", right="^ELY" },  -- (expanded)
        { "IQUE", "IY K" },
        { "I", "IH" },
    },

    ["J"] = {
        { "J", "JH" },
    },

    ["K"] = {
        { "K", "", left=" $", right="^N" },
        { "K", "K" },
    },

    ["L"] = {
        { "LO", "L OW", right="^C[AEIOUY]+" },
        { "L", "", left="L$" },
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ER" },  -- (expanded)
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^E" },  -- (expanded)
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ES" },  -- (expanded)
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ED" },  -- (expanded)
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ING" },  -- (expanded)
        { "L", "AH L", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ELY" },  -- (expanded)
        { "LEAD", "L IY D" },
        { "L", "L" },
    },

    ["M"] = {
        { "MOV", "M UW V" },
        { "M", "M" },
    },

    ["N"] = {
        { "NG", "N JH", left="E$", right="^[EIY]" },
        { "NG", "NG G", right="^R" },
        { "NG", "NG G", right="^[AEIOUY]+" },
        { "NGL", "NG G AH L", right="^ER" },  -- (expanded)
        { "NGL", "NG G AH L", right="^E" },  -- (expanded)
        { "NGL", "NG G AH L", right="^ES" },  -- (expanded)
        { "NGL", "NG G AH L", right="^ED" },  -- (expanded)
        { "NGL", "NG G AH L", right="^ING" },  -- (expanded)
        { "NGL", "NG G AH L", right="^ELY" },  -- (expanded)
        { "NG", "NG" },
        { "NK", "NG K" },
        { "NOW", "N AW", left=" $", right="^ " },
        { "N", "N" },
    },

    ["O"] = {
        { "OF", "AH V", right="^ " },
        { "OROUGH", "ER OW" },
        { "OR", "ER", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "ORS", "ER Z", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "OR", "AO R" },
        { "ONE", "W AH N", left=" $" },
        { "OW", "OW" },
        { "OVER", "OW V ER", left=" $" },
        { "OV", "AH V" },
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]ER" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]E" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]ES" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]ED" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]ING" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]ELY" },  -- (expanded)
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]EN" },
        { "O", "OW", right="^[BCDFGHJKLMNPQRSTVWXZ]I[AEIOUY]+" },
        { "OL", "OW L", right="^D" },
        { "OUGHT", "AO T" },
        { "OUGH", "AH F" },
        { "OU", "AW", left=" $" },
        { "OU", "AW", left="H$", right="^S[AEIOUY]+" },
        { "OUS", "AH S" },
        { "OUR", "AO R" },
        { "OULD", "UH D" },
        { "OU", "AH", left="[BCDFGHJKLMNPQRSTVWXZ]$", right="^[BCDFGHJKLMNPQRSTVWXZ]L" },
        { "OUP", "UW P" },
        { "OU", "AW" },
        { "OY", "OY" },
        { "OING", "OW IH NG" },
        { "OI", "OY" },
        { "OOR", "AO R" },
        { "OOK", "UH K" },
        { "OOD", "UH D" },
        { "OO", "UW" },
        { "O", "OW", right="^E" },
        { "O", "OW", right="^ " },
        { "OA", "OW" },
        { "ONLY", "OW N L IY", left=" $" },
        { "ONCE", "W AH N S", left=" $" },
        { "ON ' T", "OW N T" },
        { "O", "AA", left="C$", right="^N" },
        { "O", "AO", right="^NG" },
        { "O", "AH", left=" [BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^N" },
        { "ON", "AH N", left="I$" },
        { "ON", "AH N", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "ON", "AH N", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]$" },
        { "O", "OW", right="^ST " },
        { "OF", "AO F", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "OTHER", "AH DH ER" },
        { "OSS", "AO S", right="^ " },
        { "OM", "AH M", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$" },
        { "O", "AA" },
    },

    ["P"] = {
        { "PH", "F" },
        { "PEOP", "P IY P" },
        { "POW", "P AW" },
        { "PUT", "P UH T", right="^ " },
        { "P", "P" },
    },

    ["Q"] = {
        { "QUAR", "K W AO R" },
        { "QU", "K W" },
        { "Q", "K" },
    },

    ["R"] = {
        { "RE", "R IY", left=" $", right="^[BCDFGHJKLMNPQRSTVWXZ][AEIOUY]+" },
        { "R", "R" },
    },

    ["S"] = {
        { "SH", "SH" },
        { "SION", "ZH AH N", left="[AEIOUY]+$" },
        { "SOME", "S AH M" },
        { "SUR", "ZH ER", left="[AEIOUY]+$", right="^[AEIOUY]+" },
        { "SUR", "SH ER", right="^[AEIOUY]+" },
        { "SU", "ZH UW", left="[AEIOUY]+$", right="^[AEIOUY]+" },
        { "SSU", "SH UW", left="[AEIOUY]+$", right="^[AEIOUY]+" },
        { "SED", "Z D", left="[AEIOUY]+$", right="^ " },
        { "S", "Z", left="[AEIOUY]+$", right="^[AEIOUY]+" },
        { "SAID", "S EH D" },
        { "SION", "SH AH N", left="[BCDFGHJKLMNPQRSTVWXZ]$" },
        { "S", "", right="^S" },
        { "S", "Z", left="[BDVGJLMNRWZ]$", right="^ " },
        { "S", "Z", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*[BDVGJLMNRWZ]E$", right="^ " },
        { "S", "Z", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+[AEIOUY]+$", right="^ " },
        { "S", "S", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+$", right="^ " },
        { "S", "S", left="U$", right="^ " },
        { "S", "Z", left=" [BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+$", right="^ " },
        { "SCH", "S K", left=" $" },
        { "S", "", right="^C[EIY]" },
        { "SM", "Z M", left="[AEIOUY]+$" },
        { "SN", "Z AH N", left="[AEIOUY]+$", right="^ '" },
        { "S", "S" },
    },

    ["T"] = {
        { "THE", "DH AH", left=" $", right="^ " },
        { "TO", "T UW", right="^ " },
        { "THAT", "DH AE T", right="^ " },
        { "THIS", "DH IH S", left=" $", right="^ " },
        { "THEY", "DH EY", left=" $" },
        { "THERE", "DH EH R", left=" $" },
        { "THER", "DH ER" },
        { "THEIR", "DH EH R" },
        { "THAN", "DH AE N", left=" $", right="^ " },
        { "THEM", "DH EH M", left=" $", right="^ " },
        { "THESE", "DH IY Z", right="^ " },
        { "THEN", "DH EH N", left=" $" },
        { "THROUGH", "TH R UW" },
        { "THOSE", "DH OW Z" },
        { "THOUGH", "DH OW", right="^ " },
        { "THUS", "DH AH S", left=" $" },
        { "TH", "TH" },
        { "TED", "T IH D", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "TI", "CH", left="S$", right="^[AEIOUY]+N" },
        { "TI", "SH", right="^O" },
        { "TI", "SH", right="^A" },
        { "TIEN", "SH AH N" },
        { "TUR", "CH ER", right="^[AEIOUY]+" },
        { "TU", "CH UW", right="^A" },
        { "TWO", "T UW", left=" $" },
        { "T", "T" },
    },

    ["U"] = {
        { "UN", "Y UW N", left=" $", right="^I" },
        { "UN", "AH N", left=" $" },
        { "UPON", "AH P AO N", left=" $" },
        { "UR", "UH R", left="[TSRDLZNJ]$", right="^[AEIOUY]+" },  -- (expanded)
        { "UR", "UH R", left="TH$", right="^[AEIOUY]+" },  -- (expanded)
        { "UR", "UH R", left="CH$", right="^[AEIOUY]+" },  -- (expanded)
        { "UR", "UH R", left="SH$", right="^[AEIOUY]+" },  -- (expanded)
        { "UR", "Y UH R", right="^[AEIOUY]+" },
        { "UR", "ER" },
        { "U", "AH", right="^[BCDFGHJKLMNPQRSTVWXZ] " },
        { "U", "AH", right="^[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]" },
        { "UY", "AY" },
        { "U", "", left=" G$", right="^[AEIOUY]+" },
        { "U", "", left="G$", right="^ER" },  -- (expanded)
        { "U", "", left="G$", right="^E" },  -- (expanded)
        { "U", "", left="G$", right="^ES" },  -- (expanded)
        { "U", "", left="G$", right="^ED" },  -- (expanded)
        { "U", "", left="G$", right="^ING" },  -- (expanded)
        { "U", "", left="G$", right="^ELY" },  -- (expanded)
        { "U", "W", left="G$", right="^[AEIOUY]+" },
        { "U", "Y UW", left="[AEIOUY]+N$" },
        { "U", "UW", left="[TSRDLZNJ]$" },  -- (expanded)
        { "U", "UW", left="TH$" },  -- (expanded)
        { "U", "UW", left="CH$" },  -- (expanded)
        { "U", "UW", left="SH$" },  -- (expanded)
        { "U", "Y UW" },
    },

    ["V"] = {
        { "VIEW", "V Y UW" },
        { "V", "V" },
    },

    ["W"] = {
        { "WERE", "W ER", left=" $" },
        { "WA", "W AA", right="^S" },
        { "WA", "W AA", right="^T" },
        { "WHERE", "W EH R" },
        { "WHAT", "W AA T" },
        { "WHOL", "HH OW L" },
        { "WHO", "HH UW" },
        { "WH", "W" },
        { "WAR", "W AO R" },
        { "WOR", "W ER", right="^[BCDFGHJKLMNPQRSTVWXZ]" },
        { "WR", "R" },
        { "W", "W" },
    },

    ["X"] = {
        { "X", "K S" },
    },

    ["Y"] = {
        { "YOUNG", "Y AH NG" },
        { "YOU", "Y UW", left=" $" },
        { "YES", "Y EH S", left=" $" },
        { "Y", "Y", left=" $" },
        { "Y", "IY", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "Y", "IY", left="[AEIOUY]+[BCDFGHJKLMNPQRSTVWXZ][BCDFGHJKLMNPQRSTVWXZ]*$", right="^I" },
        { "Y", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^ " },
        { "Y", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^[AEIOUY]+" },
        { "Y", "IH", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^[BCDFGHJKLMNPQRSTVWXZ][EIY][BCDFGHJKLMNPQRSTVWXZ]*[AEIOUY]+" },
        { "Y", "AY", left=" [BCDFGHJKLMNPQRSTVWXZ]*$", right="^[BCDFGHJKLMNPQRSTVWXZ][AEIOUY]+" },
        { "Y", "IH" },
    },

    ["Z"] = {
        { "Z", "Z" },
    },

}

-- =============================================================
-- SECTION 6: CMU Dictionary + Caching
-- =============================================================
local _cmudict   = nil
local _loaded    = false

local function ensure_data()
    if _loaded then return end

    -- Load CMU Dictionary
    -- Expected format: "WORD  PH1 PH2 PH3" (two spaces, no stress numbers needed)
    -- CMUdict variants like "WORD(1)" are handled by stripping the suffix.
--    local path = "lua/data/eng_mfa_dict.txt"
    local path = "lua/data/eng_mfa_dict.txt"

    if not vocal.io.file_exists(path) then
        vocal.log("ERROR: CMUdict not found at " .. path)
        _loaded = true
        return
    end

    _cmudict = {}
    local content = vocal.io.read_text(path)
    local lines   = vocal.text.split(content, "\n")
    local count   = 0

	local _cmudict_prob = {}

	for _, line in ipairs(lines) do
		if not line:match("^%s*;;;") and line:match("%S") then
			local parts = vocal.text.split(line, "\t")
			if #parts >= 6 then
				local word = vocal.text.trim(parts[1]):upper()
				local clean_word = word:gsub("%(%d+%)$", "")
				local prob = tonumber(parts[2]) or 0.0

				if not _cmudict[clean_word] or prob > (_cmudict_prob[clean_word] or 0) then
                    local arpa_phones = vocal.text.split(vocal.text.trim(parts[6]), " ")
                    local phones = {}
                    for _, ph in ipairs(arpa_phones) do
                        local stress = ph:match("%d+$")
                        local clean  = (ph:gsub("%d+$", ""))
                        if clean == "AH" then
                            if stress == "0" then
                                table.insert(phones, "AX")  -- unstressed schwa -> ə
                            else
                                table.insert(phones, "AH")  -- stressed -> ʌ
                            end
                        elseif clean:match("^[A-Z]+$") then
                            table.insert(phones, clean)
                        end
                    end
                    local phoneme_str = table.concat(phones, " ")
                    if phoneme_str ~= "" then
                        if not _cmudict[clean_word] then
                            count = count + 1
                        end
                        _cmudict[clean_word] = phoneme_str
                        _cmudict_prob[clean_word] = prob
                    end					
				end
			end
		end
	end

	_cmudict_prob = nil
    _loaded = true
    vocal.log("CMUdict loaded: " .. count .. " entries.")
end

-- =============================================================
-- SECTION 7: G2P Pipeline
-- Layer 1: CMUdict direct lookup
-- Layer 2: Affix stripping (prefix + suffix)
-- Layer 3: NRL fallback
-- =============================================================

-- Layer 1: Direct CMUdict lookup
local function lookup_dict(word)
    return _cmudict and _cmudict[word:upper()] or nil
end

-- Layer 2a: Try suffix stripping
-- Returns phoneme string or nil
local function try_suffix(word)
    local upper = word:upper()

    for _, suf in ipairs(SUFFIXES) do
        local strip = suf.strip
        -- Check word ends with this suffix and is long enough
        if #upper > #strip and upper:sub(-#strip) == strip then
            local root = upper:sub(1, -(#strip + 1))
            -- Try all candidate root restorations
            local candidates = suf.restore(root)
            for _, candidate in ipairs(candidates) do
                local root_phones = lookup_dict(candidate)
                if root_phones then
                    -- Found root in dict. Combine root + suffix phonemes.
                    if suf.phonemes ~= "" then
                        return root_phones .. " " .. suf.phonemes
                    else
                        return root_phones
                    end
                end
            end
        end
    end
    return nil
end

-- Layer 2b: Try prefix stripping
-- Returns phoneme string or nil
local function try_prefix(word)
    local upper = word:upper()

    for _, pre in ipairs(PREFIXES) do
        local match = pre.match
        -- Check word starts with this prefix and remainder is long enough
        if #upper > #match + 2 and upper:sub(1, #match) == match then
            local remainder = upper:sub(#match + 1)
            -- Try remainder directly in dict
            local root_phones = lookup_dict(remainder)
            if root_phones then
                return pre.phonemes .. " " .. root_phones
            end
            -- Try remainder with suffix stripping
            local suffix_phones = try_suffix(remainder)
            if suffix_phones then
                return pre.phonemes .. " " .. suffix_phones
            end
        end
    end
    return nil
end

-- Full G2P for a single word
local function g2p_word(word)
    if not word or word == "" then return "" end

    local upper = word:upper()
        :gsub("[%.,!%?;:\"%(%)%[%]{}]", "") -- Strip punctuation
        :gsub("'S$", "")                     -- Strip possessive 'S

    if upper == "" then return "" end

    -- Layer 1: Direct CMUdict lookup
    local phones = lookup_dict(upper)
    if phones then return phones end

    -- Layer 2a: Suffix stripping
    phones = try_suffix(upper)
    if phones then return phones end

    -- Layer 2b: Prefix stripping
    phones = try_prefix(upper)
    if phones then return phones end

    -- Layer 3: NRL fallback
    phones = nrl_g2p(upper, NRL_RULES)
    if phones and phones ~= "" then return phones end

    -- Last resort: silence marker
    vocal.log("G2P FAILED for word: '" .. upper .. "'")
    return "SIL"
end

-- Convert ARPAbet token sequence to IPA
local function arpa_to_ipa(arpa_str)
    if not arpa_str or arpa_str == "" then return "" end
    local tokens = vocal.text.split(arpa_str, " ")
    local ipa    = {}
    for _, tok in ipairs(tokens) do
        local t   = vocal.text.trim(tok)
        local sym = ARPA_TO_IPA[t]
        if sym then
            table.insert(ipa, sym)
        elseif t ~= "" then
            -- Unknown token: log and skip
            vocal.log("IPA: unknown ARPAbet token '" .. t .. "'")
        end
    end
    return table.concat(ipa, " ")
end

-- =============================================================
-- SECTION 8: Profile Interface (LUA_GUIDE.md contract)
-- =============================================================

function profile.g2p_batch(lines)
    ensure_data()
    local results = {}

    for i, line in ipairs(lines) do
        local clean = vocal.text.trim(vocal.text.lower(line)):upper()
        local words = vocal.text.split(clean, " ")
        local line_ipa = {}

        for _, word in ipairs(words) do
            local w = vocal.text.trim(word)
            if w ~= "" then
                local arpa = g2p_word(w)
                local ipa  = arpa_to_ipa(arpa)
                if ipa ~= "" then
                    table.insert(line_ipa, ipa)
                end
            end
        end

        results[i] = table.concat(line_ipa, " ")
    end

    return results
end

-- Optional reverse lookup (ARPAbet/IPA -> Word)
-- Not implemented for NRL-based profiles (no reverse rules exist)
function profile.try_p2g(phonemes)
    return nil
end

return profile
